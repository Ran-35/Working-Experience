import{_ as e,c as l,o as r,ae as a}from"./chunks/framework.DdJmP4Xu.js";const c=JSON.parse('{"title":"设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"zh/skillOdyssey/thoughtSource/designPatterns/Design-Patterns.md","filePath":"zh/skillOdyssey/thoughtSource/designPatterns/Design-Patterns.md","lastUpdated":null}'),i={name:"zh/skillOdyssey/thoughtSource/designPatterns/Design-Patterns.md"};function n(s,t,o,d,p,g){return r(),l("div",null,[...t[0]||(t[0]=[a('<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><h2 id="什么是设计模式" tabindex="-1">什么是设计模式？ <a class="header-anchor" href="#什么是设计模式" aria-label="Permalink to &quot;什么是设计模式？&quot;">​</a></h2><p>软件开发过程中，针对某类常见问题，经过反复验证、总结出来的、可重用的解决方案。它们并不是直接的代码，而是设计上的一种思想或策略。</p><h2 id="设计模式的分类" tabindex="-1">设计模式的分类？ <a class="header-anchor" href="#设计模式的分类" aria-label="Permalink to &quot;设计模式的分类？&quot;">​</a></h2><h3 id="一、创建型设计模式" tabindex="-1">一、创建型设计模式 <a class="header-anchor" href="#一、创建型设计模式" aria-label="Permalink to &quot;一、创建型设计模式&quot;">​</a></h3><p>关注对象的<strong>创建过程</strong>，旨在通过不同的方式来控制对象的实例化，确保对象的创建方式能够满足需求。</p><ul><li><p>单例模式（Singleton）：确保类只有一个实例，并提供全局访问点。</p></li><li><p>工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定实例化哪个类。</p></li><li><p>抽象工厂模式（Abstract Factory）：创建一组相关或互相依赖的对象，而不需要明确指定具体的类。</p></li><li><p>建造者模式（Builder）：将一个复杂对象的构建过程分解成多个步骤，允许用户选择不同的步骤来创建不同的表示。</p></li><li><p>原型模式（Prototype）：通过复制现有的对象来创建新对象，而不是通过构造函数来创建。</p></li></ul><table tabindex="0"><thead><tr><th style="text-align:center;"><strong>适用场景</strong></th><th style="text-align:center;"><strong>直接 <code>new</code> 对象</strong></th><th style="text-align:center;"><strong>工厂模式</strong></th></tr></thead><tbody><tr><td style="text-align:center;"><strong>项目规模</strong></td><td style="text-align:center;">简单项目，需求不复杂</td><td style="text-align:center;">大型项目，需要良好的架构</td></tr><tr><td style="text-align:center;"><strong>需求</strong></td><td style="text-align:center;">不需要多态或接口切换</td><td style="text-align:center;">需要支持多种实现或易于扩展</td></tr><tr><td style="text-align:center;"><strong>对象创建</strong></td><td style="text-align:center;">对象数量少，创建逻辑简单</td><td style="text-align:center;">对象创建逻辑复杂</td></tr><tr><td style="text-align:center;"><strong>开发方式</strong></td><td style="text-align:center;">原型开发或快速验证</td><td style="text-align:center;">需要统一管理对象创建</td></tr><tr><td style="text-align:center;"><strong>设计原则</strong></td><td style="text-align:center;">不强调遵循设计原则，主要是简单快速实现</td><td style="text-align:center;">遵循设计原则，如开闭原则、依赖倒置原则等</td></tr></tbody></table><h3 id="二、结构型设计模式" tabindex="-1">二、结构型设计模式 <a class="header-anchor" href="#二、结构型设计模式" aria-label="Permalink to &quot;二、结构型设计模式&quot;">​</a></h3><p>主要关注<strong>类和对象的组合</strong>，通过组合现有的类和对象来达到新的功能</p><ul><li><p>适配器模式（Adapter）：将一个类的接口转换成客户端期望的另一个接口。</p></li><li><p>桥接模式（Bridge）：将抽象部分与实现部分分离，使它们可以独立地变化。</p></li><li><p>组合模式（Composite）：将对象组合成树形结构，以表示“部分-整体”的层次结构。</p></li><li><p>装饰器模式（Decorator）：动态地给一个对象添加一些额外的职责。</p></li><li><p>外观模式（Facade）：为复杂的子系统提供一个简单的接口。</p></li><li><p>享元模式（Flyweight）：通过共享对象来支持大量细粒度对象的高效使用。</p></li><li><p>代理模式（Proxy）：为其他对象提供代理以控制对该对象的访问。</p></li></ul><h3 id="三、行为型设计模式" tabindex="-1">三、行为型设计模式 <a class="header-anchor" href="#三、行为型设计模式" aria-label="Permalink to &quot;三、行为型设计模式&quot;">​</a></h3><p>关注对象之间的<strong>通信和职责分配</strong>，优化对象之间的交互和流程</p><ul><li><p>责任链模式（Chain of Responsibility）：将请求沿着处理链传递，直到有对象处理该请求。</p></li><li><p>命令模式（Command）：将请求封装为对象，从而可以用不同的请求对客户进行参数化。</p></li><li><p>解释器模式（Interpreter）：为语言的语法规则定义一个解释器。</p></li><li><p>迭代器模式（Iterator）：提供一种顺序访问一个集合对象中的元素，而不暴露其内部表示。</p></li><li><p>中介者模式（Mediator）：定义一个中介对象来协调不同对象之间的交互。</p></li><li><p>备忘录模式（Memento）：在不暴露对象的内部结构的情况下，保存对象的状态。</p></li><li><p>观察者模式（Observer）：当一个对象的状态改变时，自动通知所有依赖于它的对象。</p></li><li><p>状态模式（State）：允许对象在其内部状态改变时改变其行为。</p></li><li><p>策略模式（Strategy）：定义一系列算法，并让它们之间可以互换，使得算法可以独立于使用它的客户而变化。</p></li><li><p>模板方法模式（Template Method）：定义一个算法的框架，允许子类在不改变算法结构的情况下重新定义某些步骤。</p></li><li><p>访问者模式（Visitor）：允许你在不改变类的前提下添加新的操作。</p></li></ul><h2 id="设计模式的优点" tabindex="-1">设计模式的优点？ <a class="header-anchor" href="#设计模式的优点" aria-label="Permalink to &quot;设计模式的优点？&quot;">​</a></h2><ol><li><strong>封装变化</strong>：将抽象与实现分离，使得抽象部分不会因为实现部分而改变。</li><li><strong>复用性高</strong>：设计模式是经过验证的最佳实践，可以在多个项目中复用，减少了开发中的重复劳动。</li><li><strong>提高代码可维护性</strong>：采用设计模式后，代码结构更加清晰，易于理解和修改，减少了系统的复杂性。</li><li><strong>解决复杂问题</strong>：设计模式提供了解决软件设计中常见问题的标准方法，避免了“重复造轮子”的问题。</li></ol>',16)])])}const u=e(i,[["render",n]]);export{c as __pageData,u as default};
