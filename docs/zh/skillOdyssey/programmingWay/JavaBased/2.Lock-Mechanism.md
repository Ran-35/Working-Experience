# 锁机制

✅**锁**：是一种常用的同步机制，用于确保多线程在执行共享资源访问时，能够以互斥的方式进行，防止多个线程同时访问或修改共享资源导致的不一致性。

✅**乐观锁**：假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。

✅**悲观锁**：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。

| **维度**   | **悲观锁 (Pessimistic)**                                  | **乐观锁 (Optimistic)**  |
| -------- | ------------------------------------------------------ | --------------------- |
| **核心思想** | "总有刁民想害朕"，操作前先加锁。                                      | "大家都是好人"，更新时再检查。      |
| **实现方式** | `synchronized`、`ReentrantLock`、数据库 `select for update` | `CAS` 机制、版本号机制        |
| **开销**   | 涉及线程阻塞、上下文切换，开销大。                                      | 不阻塞线程，但在高竞争下 CPU 消耗高。 |
| **适用场景** | 写多读少，竞争激烈，同步块长。                                        | 读多写少，竞争不激烈。           |

## 1. volatile

Java 虚拟机提供的最轻量级的同步机制。与 synchronized 不同，它不具备互斥性（不会引起线程阻塞），主要用于解决多线程间的可见性和有序性问题。

### 1.1 保证可见性(Visibility)

在多线程环境下，每个线程都有自己的工作内存（高速缓存）。当一个线程修改了普通变量，其他线程可能无法立即看到。
| **类型**          | **描述**                                                     |
| --------------- | ---------------------------------------------------------- |
| **普通变量**        | 修改后可能还在缓存里，没及时写回主存。                                        |
| **volatile 变量** | 一旦被修改，JVM 会立即将其刷新到主内存，并使其他线程工作内存中的副本失效(禁用CPU缓存)。线程读取时必须从主内存重新获取最新值。 |

### 1.2 保证有序性 (Ordering)
为了优化性能，编译器和处理器会对指令进行重排序。
| **类型**     | **描述**                                                                |
| ---------- | --------------------------------------------------------------------- |
| **禁止指令重排** | `volatile` 通过插入内存屏障 (Memory Barrier)，确保指令执行顺序。                        |
| **经典案例**   | 单例模式的 DCL（双重检查锁定）必须给实例变量加 `volatile`，防止对象尚未初始化完成（构造函数未执行完）就把引用赋值给了变量。 |

### 1.3 不保证原子性
volatile 只能保证单次读/写的原子性（例如 long/double 的读写），但不能保证复合操作（如 i++）的原子性。
**示例**
```java
// 原因：线程 A 读取了 count=5，此时线程 B 也读取了 count=5。A 加 1 后写回 6，B 稍后也写回 6。两次自增操作，实际上只增加了一次。
public class VolatileTest {
    public volatile int count = 0;

    public void add() {
        count++; // 这是一个复合操作：读取 -> 增加 -> 写入
    }

    public static void main(String[] args) throws InterruptedException {
        VolatileTest test = new VolatileTest();
        // 启动10个线程，每个线程加1000次
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int j = 0; j < 1000; j++) test.add();
            }).start();
        }
        Thread.sleep(2000);
        System.out.println(test.count); // 结果通常小于 10000
    }
}
```
### 1.4 使用场景
1. 状态标志位：如 volatile boolean stop = false; 用于停止线程。

2. 双重检查锁定 (DCL)：单例模式中防止指令重排导致的空指针异常。

3. 读多写少：只有一个线程修改变量，其他多个线程读取。


## 2. 悲观锁-Synchronized（内置锁）

最基本的锁机制：`Synchronized`关键字，其是 Java 提供的原子性内置锁，其核心思想是：任意一个对象都可以作为一个锁。

### 2.1 底层原理

📌 synchronized 的核心是 Monitor（监视器锁）。每个 Java 对象在 JVM 内部都关联着一个 Monitor 对象。

👉 **monitorenter**：每个对象有一个锁计数器。当计数器为 0 时，线程进入并将其设为 1，该线程成为 Monitor 的所有者（Owner）。如果是重入，计数器递增。  
👉 **monitorexit**：线程释放锁，计数器减 1。当减至 0 时，锁被彻底释放。

⚠️ 关键点：synchronized 是可重入的。它通过 Monitor 内部的 recursions 计数器来跟踪当前线程获取了多少次锁。

### 2.2 锁升级过程
✅ 为了平衡“高并发下的安全性”和“单线程下的高性能”，锁会经历从低到高的膨胀过程：

#### 2.2.1 第一阶段：偏向锁 (Biased Locking)
📌 **原理**：大多数情况下，锁不仅不存在竞争，还总是由同一个线程获得。偏向锁会在 Mark Word 里记录这个线程的 ID。  
👉 **操作**：后续该线程进入时，只需对比线程 ID，无需任何同步操作（无 CAS，无内存屏障）。  
👉 **触发升级**：当有第二个线程尝试竞争该锁时，偏向锁失效。

#### 2.2.2 第二阶段：轻量级锁 (Lightweight Locking)
📌 **原理**：当出现竞争，但竞争不激烈（线程交替执行）时，锁升级为轻量级锁。  
👉 **操作**：JVM 会在当前线程的栈帧中创建一个“锁记录”（Lock Record），尝试用 CAS 把对象头的 Mark Word 替换为指向锁记录的指针。  
👉 **自旋优化**：如果 CAS 失败，线程不会立即挂起，而是进行自旋（空循环），等待持有锁的线程释放。

#### 2.2.3 第三阶段：重量级锁 (Heavyweight Locking)
📌 **原理**：如果竞争非常激烈，线程自旋达到一定次数（或有多个线程在排队），锁膨胀为重量级锁。  
👉 **操作**：Mark Word 指向 Monitor。未抢到锁的线程会进入 阻塞（Blocked） 状态，交给操作系统调度。  
👉 **开销**：涉及用户态到内核态的上下文切换，性能损耗最高。  

#### 2.2.4 设计哲学
🏷️ 偏向锁：为了让单线程执行同步块时，像没加锁一样快。  
🏷️ 轻量级锁：为了在有短时间竞争时，避免线程挂起带来的系统调用开销。  
🏷️ 重量级锁：为了在长期、激烈的竞争中，通过挂起线程来节省 CPU 资源（避免无效自旋）。  

### 2.3 几种用法
#### 2.3.1 实例锁（锁对象实例）
📌 **作用**：锁住的是当前的 this 对象。如果两个线程访问同一个对象的同步方法，会发生竞争；如果访问不同对象的同步方法，不会竞争。  
```java
public class SyncExample {
    // 1. 修饰实例方法
    public synchronized void method1() {
        // 临界区代码
    }

    // 2. 修饰代码块（指定锁对象）
    public void method2() {
        synchronized (this) {
            // 效果同上
        }
    }
}
```

```java
public class MyClass {
    private void increment() {}
    private synchronized void decrement() {}
}
```

| 线程A         | 线程B         | 结果   | 原因                          |
| ----------- | :---------- | :--- | :-------------------------- |
| increment() | increment() | 可以执行 | increment()未加锁              |
| increment() | decrement() | 可以执行 | 锁加到的是方法，执行的是不同的方法           |
| decrement() | decrement() | 无法执行 | decrement()被锁定，需要等其中一个进程释放锁 |

---
#### 2.3.2 类锁（锁 Class 对象）

📌 **作用**：锁住的是该类的 `Class` 模板。无论创建多少个实例，该类的类锁只有一把。
```java
public class SyncExample {
    // 1. 修饰静态方法
    public static synchronized void staticMethod() {
        // 全局唯一锁
    }

    // 2. 修饰代码块（锁指定类）
    public void method3() {
        synchronized (SyncExample.class) {
            // 效果同上
        }
    }
}
```
```java
public class MyClass {
    private static void increment() {}
    private static synchronized void decrement1() {}
    private static synchronized void decrement2() {}
}
```

| 线程A          | 线程B          | 结果   | 原因                |
| ------------ | :----------- | :--- | :---------------- |
| increment()  | increment()  | 可以执行 | increment()未加锁    |
| increment()  | increment1() | 无法执行 | 锁到了类，需要等其中一个进程释放锁 |
| decrement1() | decrement1() | 无法执行 | 锁到了类，需要等其中一个进程释放锁 |
| decrement1() | decrement2() | 无法执行 | 锁到了类，需要等其中一个进程释放锁 |


### 2.4 synchronized 与 voliate区别
| **特性**   | **volatile** | **synchronized**  |
| -------- | ------------ | ----------------- |
| **原子性**  | ❌ 仅保证单次读写    | ✅ 保证（互斥锁）         |
| **可见性**  | ✅            | ✅                 |
| **有序性**  | ✅ (禁止重排)     | ✅ (由互斥语义保证)       |
| **性能**   | 🚀 极高（非阻塞）   | 🐢 较低（可能涉及锁升级/阻塞） |
| **使用位置** | 变量           | 方法、代码块            |

## 3. 悲观锁-ReentrantLock（可重入锁 / 显示锁）

Java 5 引入的显式锁，比 `synchronized` 提供了更加灵活和强大的功能，允许程序员显式地控制锁的获取和释放，并提供了一些附加功能，如尝试获取锁、超时获取锁、可中断锁等。

底层原理：ReentrantLock 的核心灵魂是 AQS。它是一个用于构建锁和同步器的框架。

### 3.1 核心特性

#### 3.1.1 显式创建、加锁与释放
**创建**：`ReentrantLock lock = new ReentrantLock();`
**获取**：`lock.lock()`
**释放**：`lock.unlock()`

```java
public class MyClass {
    private final ReentrantLock lock = new ReentrantLock();

    public void test() {
        lock.lock();
        try {
            // 访问共享资源
        } finally {
            lock.unlock();
        }
    }
}
```

#### 3.1.2 可重入性

同一个线程可以多次获得同一把锁。如果线程已经获得了锁，它仍然可以再次获取这把锁而不会发生死锁。

```java
public class MyClass {
    private final ReentrantLock lock = new ReentrantLock();

    public void methodA() {
        lock.lock();
        try {
            methodB(); // 在 methodA 内部调用 methodB
        } finally {
            lock.unlock();
        }
    }

    public void methodB() {
        lock.lock();  // 当前线程再次获得锁
        try {
            System.out.println("Executing methodB...");
        } finally {
            lock.unlock();
        }
    }
}
```

#### 3.1.3 超时机制

`ReentrantLock` 提供了 `tryLock()` 方法，它不会阻塞当前线程，如果锁不可用，它会立刻返回 `false`，不会死等。
**使用场景**：需要避免阻塞的场景。

* `tryLock()`：尝试获取锁，如果锁不可用，则立即返回 `false`。
* `tryLock(long timeout, TimeUnit unit)`：尝试获取锁，如果锁不可用，则等待指定的时间。若在指定时间内还无法获得，则返回 `false`。

```java
public class MyClass {
    private final ReentrantLock lock = new ReentrantLock();

    public void test() {
        if (lock.tryLock()) {
            try {
                // 访问共享资源
            } finally {
                lock.unlock();
            }
        } else {
            // 如果锁不可用，执行其他操作
        }
    }
}
```

#### 3.1.4 响应中断

可中断锁允许线程在等待锁时被中断，并抛出一个异常。

**使用场景**：在高并发或长时间等待锁时，线程需要在等待锁的时候能够被外部中断。

* `lockInterruptibly()`：让一个线程在等待锁的过程中被中断。如果线程在获取锁之前被中断，它会抛出 `InterruptedException`。

```java
public class MyClass {
    private final ReentrantLock lock = new ReentrantLock();

    public void test() {
        try {
            lock.lockInterruptibly();
        } catch (InterruptedException e) {
            // 处理中断异常
        } finally {
            lock.unlock();
        }
    }
}
```

#### 3.1.5 公平锁与非公平锁

默认情况下，`ReentrantLock` 是非公平锁，即获取锁的顺序是任意的，哪个线程先执行，哪个线程就先获得锁。

**公平锁**：能确保线程按请求顺序获得锁，从而避免“饥饿”问题，但性能可能较差。
**非公平锁**：获取锁的顺序是任意的，哪个线程先执行，哪个线程就先获得锁。

```java
ReentrantLock fairLock = new ReentrantLock();     // 默认是非公平锁
ReentrantLock fairLock = new ReentrantLock(true); // true 表示公平锁
```

### 3.2 锁升级
1️⃣**直接尝试**：线程进来先尝试用 CAS 将 state 从 0 改为 1。成功则直接获取锁。

2️⃣**判断重入**：如果失败，检查当前线程是否已经是锁的持有者。如果是，state++，获取成功。

3️⃣**入队挂起**：如果以上都失败，线程被放入 AQS 队列的尾部，并通过 LockSupport.park() 挂起（进入等待状态）。

4️⃣**阻塞自旋**：在队列中的线程会不断尝试获取锁（通常是队头线程），直到成功获取。



### 3.3 使用场景

* **高并发**：多个线程竞争锁时，`ReentrantLock` 提供了比 `synchronized` 更加灵活的控制，如可中断锁、定时锁等。
* **复杂的同步需求**：当需要多种锁定机制（如公平性、尝试锁、可中断锁等）时，`ReentrantLock` 提供了更多选项。
* **避免死锁**：可以通过锁的顺序控制和 `tryLock()` 等方法来避免死锁。


### 3.4 ReentrantLock 与 Synchronized 对比
| 特性       | Synchronized        | ReentrantLock    |
| -------- | ------------------- | ---------------- |
| **实现层面** | JVM 关键字（C++ 实现）     | JDK API（Java 实现） |
| **灵活性**  | 自动加锁/释放，较死板         | 手动控制，极其灵活        |
| **公平性**  | 只支持非公平              | 支持公平与非公平         |
| **中断响应** | 不可中断                | 可中断              |
| **条件变量** | 只有一个 (wait/notify)  | 支持多个 Condition   |
| **性能**   | Java 6 优化后与 Lock 持平 | 高竞争下通常表现更稳定      |

---

## 4. 悲观锁-ReadWriteLock（读写锁）

✅ 概念：Java 提供的一种锁接口，它通过将锁分为`读锁（readLock)`和`写锁（writeLock)`来提高性能。
设计目标：允许多个线程并发地读取数据。但是在写入数据时，其他线程无法进行读取或写入。

📅 底层原理：基于 AQS，但 AQS 只有一个 state 变量，读写锁巧妙地将其“一分为二”：
* 高 16 位：代表读锁状态（持有读锁的次数，如果是重入则累加）。
* 低 16 位：代表写锁状态（写锁重入次数）。
* 写锁获取：当 state 的低 16 位为 0 且高 16 位也为 0 时，可以获取写锁。
* 读锁获取：只要低 16 位（写锁）为 0，无论高 16 位是多少，线程都可以通过 CAS 增加高 16 位的值来获取读锁。
### 4.1 核心规则
✅ ReadWriteLock 的核心逻辑可以总结为：“读读共享、读写互斥、写写互斥”。

| 锁状态            | 读锁 (Read)  | 写锁 (Write) |
| -------------- | ---------- | ---------- |
| **读锁 (Read)**  | ✅ 允许 (并发读) | ❌ 阻塞       |
| **写锁 (Write)** | ❌ 阻塞       | ❌ 阻塞       |


### 4.2 读锁、写锁与创建读写锁
* `readLock()`：读锁。

(1) 读锁是共享锁，多个线程可以同时获得同一个读锁，只要没有线程持有写锁。  
(2) 读锁的获取是非独占的，多个线程可以同时读取数据，从而提高性能。   
(3) 读锁不能与写锁同时存在。即如果有线程持有读锁，其他线程不能获取写锁。  

* `writeLock()`：写锁。  

(1) 写锁是排它锁，写锁是独占的，当一个线程持有写锁时，其他线程无法获得写锁或读锁。  
(2) 写锁会阻塞所有读锁和其他写锁，直到写操作完成。  
(3) 写锁具有更高的优先级，因为它需要保证数据的一致性。  

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class CacheData {
    private Object data;
    // 创建读写锁
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void read() {
        rwLock.readLock().lock(); // 申请读锁
        try {
            System.out.println(Thread.currentThread().getName() + " 正在读数据: " + data);
        } finally {
            rwLock.readLock().unlock();
        }
    }

    public void write(Object newData) {
        rwLock.writeLock().lock(); // 申请写锁
        try {
            System.out.println(Thread.currentThread().getName() + " 正在写数据...");
            this.data = newData;
        } finally {
            rwLock.writeLock().unlock();
        }
    }
}
```

### 4.3 锁降级
⭐ReentrantReadWriteLock 支持锁降级，即：获取写锁 -> 获取读锁 -> 释放写锁。这样线程可以在不释放锁的情况下，从写模式切换到读模式，保证了数据的可见性。

⚠️注意：不支持锁升级（从读锁直接变写锁会死锁）。

### 4.4 ReentrantReadWriteLock 与 ReentrantLock对比
| **维度**   | **ReentrantLock** | **ReentrantReadWriteLock** |
| -------- | ----------------- | -------------------------- |
| **并发性**  | 完全互斥              | 读操作并发执行                    |
| **适用场景** | 写操作多，或读写比例均衡      | 读多写少（如缓存查询、配置读取）           |
| **开销**   | 较低                | 略高（维护两把锁的状态）               |

## 5. 乐观锁-版本号机制(Version)
✅ 核心逻辑：读取时带走版本，更新时回比版本

数据库层面最常用的方式。在表中增加一个 version 字段。  
1️⃣ 初始状态：数据库记录包含数据字段和 version 字段（通常从 0 或 1 开始）。  
2️⃣ 读取阶段：线程 A 读取数据，同时也读取到当前的 version = 1。  
3️⃣ 逻辑处理：线程 A 在内存中修改数据。  
4️⃣ 写入阶段：线程 A 准备提交更新，此时会执行带有条件的 SQL。

    4.1 检查：数据库检查当前这条记录的 version 是否还是 1。  
    4.2 成功：如果还是 1，说明期间没人改过。执行更新，并将 version 改为 2。  
    4.3 失败：如果 version 已经变成了 2（被别人抢先改了），则更新失败。  

### 5.1 版本号机制 vs 时间戳机制 
| 方式    | 优点                             | 缺点                            |
| ----- | ------------------------------ | ----------------------------- |
| 数字版本号 | 简单、精确、不受系统时间影响。                | 需要维护一个额外的字段。                  |
| 时间戳   | 无需额外逻辑，通常表里本身就有 `update_time`。 | 在高并发下（毫秒级），若两个请求同时到达，时间戳可能相同。 |

⚠️ 注意：由于分布式环境下服务器时钟可能不一致，数字版本号通常比时间戳更可靠。

## 6. 乐观锁-CAS (Compare And Swap)
✅ 概念：它是一条 CPU 原子指令，能够在不使用传统锁（synchronized）的情况下，保证多线程对共享变量修改的原子性。

### 6.1 核心原理
1️⃣ V (Memory Value)：内存中的实际当前值。  
2️⃣ E (Expected Value)：预期原值（线程之前读取的值）。  
3️⃣ N (New Value)：准备更新的新值。

**执行逻辑**：当线程尝试更新一个变量时：  
* 如果 $V == E$：说明该变量没被其他线程改过，直接将 $V$ 更新为 $N$，返回成功。
* 如果 $V \neq E$：说明该变量已被其他线程修改，当前线程放弃更新（或进入自旋重试），返回失败。

### 6.2 三大缺陷
#### 6.2.1 ABA 问题
* **现象**：线程 1 读到值 A。此时线程 2 把值改为 B，接着又改回 A。线程 1 检查时发现还是 A，认为没变过，执行成功。  
* **影响**：在某些场景（如链表栈的节点复用）会导致逻辑错误。  
* **解法**：增加版本号或时间戳。Java 提供了 AtomicStampedReference，它不仅比较值，还比较“印戳（Stamp）”。

#### 6.2.2 自旋开销大
* **现象**：在高并发下，如果大量线程竞争同一个变量，CAS 会长时间失败，导致 while 循环不断空转。  
* **影响**：极度消耗 CPU。  
* **解法**：  
① 自适应自旋：限制重试次数。  
② 分段锁思想：Java 8 引入了 LongAdder。它将一个变量拆分成多个 Cell，不同线程去改不同的 Cell，最后求和，从而分散竞争。

#### 6.2.3 只能保证一个变量的原子性
* **现象**：CAS 只能对单个内存地址执行原子操作。  
* **解法**：如果需要保证多个变量的原子性，可以将它们封装进一个对象，利用 AtomicReference 来对整个对象执行 CAS。

#### 6.2.4 CAS vs Synchronized
| 维度     | CAS (乐观)          | Synchronized (悲观)  |
| ------ | ----------------- | ------------------ |
| 线程状态   | 非阻塞，线程始终在运行。      | 阻塞，未抢到锁的线程会挂起。     |
| 锁竞争激烈时 | 性能下降（大量自旋消耗 CPU）。 | 表现更稳（线程挂起，不占 CPU）。 |
| 锁竞争轻微时 | 性能极高（直接操作硬件）。     | 性能较差（即使有优化，仍有开销）。  |

## 7. 乐观锁-Atomic 原子类
**概念**：Atomic 原子类利用 CAS 操作，提供了一种**无锁**的线程安全机制，性能通常优于 synchronized。  

| 分类    | 常用类                                      | 描述                            |
| ----- | ---------------------------------------- | ----------------------------- |
| 基本类型  | AtomicInteger, AtomicLong, AtomicBoolean | 对基本变量进行原子更新。                  |
| 数组类型  | AtomicIntegerArray, AtomicReferenceArray | 原子更新数组中的某个元素。                 |
| 引用类型  | AtomicReference, AtomicStampedReference  | 原子更新对象引用（后者可解决 ABA 问题）。       |
| 字段更新器 | AtomicIntegerFieldUpdater                | 基于反射，原子更新某个类中的 `volatile` 字段。 |

### 7.1 底层原理
**核心原理**：CAS + Unsafe + volatile  

1️⃣ volatile：保证了变量在多线程之间的可见性，确保每个线程读到的都是最新值。  
2️⃣ Unsafe 类：封装了操作系统的底层指令，可以直接操作内存数据。  
3️⃣CAS 指令：通过 CPU 的原子指令（如 x86 的 cmpxchg）实现“比较并交换”。

```java 
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCounter {
    // 使用 AtomicInteger 保证原子性
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        // 相当于 count++，但它是原子性的
        count.getAndIncrement(); 
    }

    public int getCount() {
        return count.get();
    }
}
```


❓ 为什么不用 **synchronized**？  
| 锁类型          | 描述                       |
| ------------ | ------------------------ |
| synchronized | 悲观锁，会引起线程上下文切换（进入内核态）   |
| Atomic       | 乐观锁，线程在用户态通过自旋完成操作，开销极小 |

### 7.2 解决ABA问题
AtomicStampedReference 通过引入 Stamp (版本戳) 解决了这个问题：
```java 
// 初始值 100，版本戳 1
AtomicStampedReference<Integer> asr = new AtomicStampedReference<>(100, 1);

int oldStamp = asr.getStamp(); // 获取当前版本
Integer oldRef = asr.getReference();

// CAS 时不仅比对值，还比对版本号
boolean success = asr.compareAndSet(oldRef, 200, oldStamp, oldStamp + 1);
```
### 7.3 高性能并发神器 LongAdder
极高并发下，大量线程同时竞争同一个 AtomicLong 会导致大量 CAS 失败和自旋，白白浪费 CPU。Java 8 引入了 LongAdder：

✅核心思想：分段累加。
* 它内部维护了一个 Cell 数组，将竞争分散到多个变量上。
* 读取时，将所有 Cell 的值求和返回。

🧱对比结论：
* 低并发：AtomicLong 表现更好。
* 高并发：LongAdder 性能远超 AtomicLong（吞吐量提升数倍）。

### 7.4 使用场景
* 简单计数用 AtomicInteger。
* 高并发求和用 LongAdder。
* 对象修改用 AtomicReference。



## 8. 乐观锁-Java 8 的 StampedLock 的乐观读
`StampedLock` 的所有获取锁操作都会返回一个 Stamp（邮戳），代表了锁的状态版本。

### 8.1 底层原理
`StampedLock` 并没有直接基于 AQS，而是自己维护了一套类似的等待队列。  

* Stamp 的组成：它是一个 long 类型。低 8 位位代表锁的状态（读锁计数或写锁持有状态），高位代表版本号。  
* validate 逻辑：validate(stamp) 实际上就是对比当前锁的版本号是否与你获取时的版本号一致。如果不一致，说明期间发生过写操作（写操作会改变版本号）。

⚠️ 致命警告：不要在 StampedLock 中使用中断。  
StampedLock.readLock() 和 writeLock() 内部使用了类似于自旋的逻辑。如果在等待锁时线程被 interrupt()，可能会导致 CPU 飙升到 100%。如果需要响应中断，请务必使用 readLockInterruptibly()。

### 8.2 三种访问模式
#### ① 乐观读(Optimistic Reading)  
📍 不加锁，只是获取一个版本号。  
* 特点：不阻塞写锁。读的时候，写线程可以修改数据。
* 安全性：读取完后需要调用 validate(stamp) 检查期间数据是否被修改。

#### ② 悲观读 (Pessimistic Read)
* 特点：多个线程可以同时持有，但会阻塞写锁。

#### ③ 写锁 (Write Lock)
* 特点：独占，完全互斥。

### 8.3 使用场景
* 推荐场景：读多写少，且对性能要求极高。
* 谨慎使用：代码逻辑复杂、需要重入锁、或者对中断处理有严格要求的场景。