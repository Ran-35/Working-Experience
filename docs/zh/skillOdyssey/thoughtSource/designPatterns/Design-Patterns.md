# 设计模式

## 什么是设计模式？
软件开发过程中，针对某类常见问题，经过反复验证、总结出来的、可重用的解决方案。它们并不是直接的代码，而是设计上的一种思想或策略。
## 设计模式的分类？
### 一、创建型设计模式
关注对象的**创建过程**，旨在通过不同的方式来控制对象的实例化，确保对象的创建方式能够满足需求。
- 单例模式（Singleton）：确保类只有一个实例，并提供全局访问点。

- 工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定实例化哪个类。

- 抽象工厂模式（Abstract Factory）：创建一组相关或互相依赖的对象，而不需要明确指定具体的类。

- 建造者模式（Builder）：将一个复杂对象的构建过程分解成多个步骤，允许用户选择不同的步骤来创建不同的表示。

- 原型模式（Prototype）：通过复制现有的对象来创建新对象，而不是通过构造函数来创建。


| **适用场景** | **直接 `new` 对象**                                           | **工厂模式**                                                 |
|:----------------:|:------------------------------------------------------------:|:----------------------------------------------------------:|
| **项目规模**  | 简单项目，需求不复杂          | 大型项目，需要良好的架构|
| **需求**     | 不需要多态或接口切换          | 需要支持多种实现或易于扩展|
| **对象创建**  | 对象数量少，创建逻辑简单       | 对象创建逻辑复杂|
| **开发方式**  | 原型开发或快速验证            | 需要统一管理对象创建|
| **设计原则**  | 不强调遵循设计原则，主要是简单快速实现| 遵循设计原则，如开闭原则、依赖倒置原则等|


### 二、结构型设计模式
主要关注**类和对象的组合**，通过组合现有的类和对象来达到新的功能
- 适配器模式（Adapter）：将一个类的接口转换成客户端期望的另一个接口。

- 桥接模式（Bridge）：将抽象部分与实现部分分离，使它们可以独立地变化。

- 组合模式（Composite）：将对象组合成树形结构，以表示“部分-整体”的层次结构。

- 装饰器模式（Decorator）：动态地给一个对象添加一些额外的职责。

- 外观模式（Facade）：为复杂的子系统提供一个简单的接口。

- 享元模式（Flyweight）：通过共享对象来支持大量细粒度对象的高效使用。

- 代理模式（Proxy）：为其他对象提供代理以控制对该对象的访问。
### 三、行为型设计模式
关注对象之间的**通信和职责分配**，优化对象之间的交互和流程
- 责任链模式（Chain of Responsibility）：将请求沿着处理链传递，直到有对象处理该请求。

- 命令模式（Command）：将请求封装为对象，从而可以用不同的请求对客户进行参数化。

- 解释器模式（Interpreter）：为语言的语法规则定义一个解释器。

- 迭代器模式（Iterator）：提供一种顺序访问一个集合对象中的元素，而不暴露其内部表示。

- 中介者模式（Mediator）：定义一个中介对象来协调不同对象之间的交互。

- 备忘录模式（Memento）：在不暴露对象的内部结构的情况下，保存对象的状态。

- 观察者模式（Observer）：当一个对象的状态改变时，自动通知所有依赖于它的对象。

- 状态模式（State）：允许对象在其内部状态改变时改变其行为。

- 策略模式（Strategy）：定义一系列算法，并让它们之间可以互换，使得算法可以独立于使用它的客户而变化。

- 模板方法模式（Template Method）：定义一个算法的框架，允许子类在不改变算法结构的情况下重新定义某些步骤。

- 访问者模式（Visitor）：允许你在不改变类的前提下添加新的操作。
## 设计模式的优点？
1. **封装变化**：将抽象与实现分离，使得抽象部分不会因为实现部分而改变。
2. **复用性高**：设计模式是经过验证的最佳实践，可以在多个项目中复用，减少了开发中的重复劳动。
3. **提高代码可维护性**：采用设计模式后，代码结构更加清晰，易于理解和修改，减少了系统的复杂性。
4. **解决复杂问题**：设计模式提供了解决软件设计中常见问题的标准方法，避免了“重复造轮子”的问题。
